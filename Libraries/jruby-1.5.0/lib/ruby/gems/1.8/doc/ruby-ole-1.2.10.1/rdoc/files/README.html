<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>File: README</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href=".././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



  <div id="fileHeader">
    <h1>README</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>README
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Wed Jun 09 14:23:03 +0100 2010</td>
    </tr>
    </table>
  </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">

    <div id="description">
      <h1>Introduction</h1>
<p>
The ruby-ole library provides a variety of functions primarily for working
with OLE2 structured storage files, such as those produced by Microsoft
Office - eg *.doc, *.msg etc.
</p>
<h1>Example Usage</h1>
<p>
Here are some examples of how to use the library functionality, categorised
roughly by purpose.
</p>
<ol>
<li>Reading and writing files within an OLE container

<p>
The recommended way to manipulate the contents is via the
&quot;file_system&quot; API, whereby you use <a
href="../classes/Ole/Storage.html">Ole::Storage</a> instance methods
similar to the regular File and Dir class methods.
</p>
<pre>
  ole = Ole::Storage.open('oleWithDirs.ole', 'rb+')
  p ole.dir.entries('.') # =&gt; [&quot;.&quot;, &quot;..&quot;, &quot;dir1&quot;, &quot;dir2&quot;, &quot;file1&quot;]
  p ole.file.read('file1')[0, 25] # =&gt; &quot;this is the entry 'file1'&quot;
  ole.dir.mkdir('newdir')
</pre>
</li>
<li>Accessing OLE meta data

<p>
Some convenience functions are provided for (currently read only) access to
OLE property sets and other sources of meta data.
</p>
<pre>
  ole = Ole::Storage.open('test_word_95.doc')
  p ole.meta_data.file_format # =&gt; &quot;MSWordDoc&quot;
  p ole.meta_data.mime_type # =&gt; &quot;application/msword&quot;
  p ole.meta_data.doc_author.split.first # =&gt; &quot;Charles&quot;
</pre>
</li>
<li>Raw access to underlying OLE internals

<p>
This is probably of little interest to most developers using the library,
but for some use cases you may need to drop down to the lower level API on
which the &quot;file_system&quot; API is constructed, which exposes more of
the format details.
</p>
<p>
<tt><a href="../classes/Ole/Storage.html">Ole::Storage</a></tt> files can
have multiple files with the same name, or with a slash in the name, and
other things that are probably strictly invalid. This API is the only way
to access those files.
</p>
<p>
You can access the header object directly:
</p>
<pre>
  p ole.header.num_sbat # =&gt; 1
  p ole.header.magic.unpack('H*') # =&gt; [&quot;d0cf11e0a1b11ae1&quot;]
</pre>
<p>
You can directly access the array of all Dirent objects, including the
root:
</p>
<pre>
  p ole.dirents.length # =&gt; 5
  puts ole.root.to_tree
  # =&gt;
  - #&lt;Dirent:&quot;Root Entry&quot;&gt;
    |- #&lt;Dirent:&quot;\001Ole&quot; size=20 data=&quot;\001\000\000\002\000...&quot;&gt;
    |- #&lt;Dirent:&quot;\001CompObj&quot; size=98 data=&quot;\001\000\376\377\003...&quot;&gt;
    |- #&lt;Dirent:&quot;WordDocument&quot; size=2574 data=&quot;\334\245e\000-...&quot;&gt;
    \- #&lt;Dirent:&quot;\005SummaryInformation&quot; size=54788 data=&quot;\376\377\000\000\001...&quot;&gt;
</pre>
<p>
You can access (through <a href="../classes/RangesIO.html">RangesIO</a>
methods, or by using the relevant Dirent and AllocationTable methods)
information like where within the container a stream is located (these are
offset/length pairs):
</p>
<pre>
  p ole.root[&quot;\001CompObj&quot;].open { |io| io.ranges } # =&gt; [[0, 64], [64, 34]]
</pre>
</li>
</ol>
<p>
See the documentation for each class for more details.
</p>
<h1>Thanks</h1>
<ul>
<li>The code contained in this project was initially based on chicago&#8216;s
libole (source available at <a
href="http://prdownloads.sf.net/chicago/ole.tgz">prdownloads.sf.net/chicago/ole.tgz</a>).

</li>
<li>It was later augmented with some corrections by inspecting pole, and
(purely for header definitions) gsf.

</li>
<li>The property set parsing code came from the apache java project POIFS.

</li>
<li>The excellent idea for using a pseudo file system style interface by
providing file and dir methods which mimic File and Dir, was borrowed
(along with almost unchanged tests!) from Thomas Sondergaard&#8216;s
rubyzip.

</li>
</ul>
<h1>TODO</h1>
<h2>1.2.11</h2>
<ul>
<li>internal api cleanup

</li>
<li>add buffering to rangesio so that performance for small reads and writes
isn&#8216;t so awful. maybe try and remove the bottlenecks of unbuffered
first with more profiling, then implement the buffering on top of that.

</li>
<li>fix mode strings - like truncate when using &#8216;w+&#8217;, supporting
append &#8216;a+&#8217; modes etc. done?

</li>
<li>make ranges io obey readable vs writeable modes.

</li>
<li>more <a href="../classes/RangesIO.html">RangesIO</a> completion. ie,
doesn&#8216;t support #&lt;&lt; at the moment.

</li>
<li>maybe some oletool doc.

</li>
<li>make sure `rake test&#8217; runs tests both with $KCODE=&#8217;UTF8&#8217;,
and without, and maybe ensure i don&#8216;t regress on 1.9 and jruby either
now that they&#8216;re fixed.

</li>
</ul>
<h2>1.3.1</h2>
<ul>
<li>case insensitive open mode would be nice

</li>
<li>fix property sets a bit more. see TODO in <a
href="../classes/Ole/Storage/MetaData.html">Ole::Storage::MetaData</a>

</li>
<li>ability to zero out padding and unused blocks

</li>
<li>case insensitive mode for ole/file_system?

</li>
<li>better tests for mbat support.

</li>
<li>further doc cleanup

</li>
<li>add in place testing for jruby and ruby1.9

</li>
</ul>
<h2>Longer term</h2>
<ul>
<li>more benchmarking, profiling, and speed fixes. was thinking vs other ruby
filesystems (eg, vs File/Dir itself, and vs rubyzip), and vs other ole
implementations (maybe perl&#8216;s, and poifs) just to check its in the
ballpark, with no remaining silly bottlenecks.

</li>
<li>supposedly vba does something weird to ole files. test that.

</li>
</ul>

    </div>


   </div>


  </div>


    <!-- if includes -->

    <div id="section">





      


    <!-- if method_list -->


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>